<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lightsaber Combat - Bot Sportello</title>
    <link rel="stylesheet" href="../page-theme.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');

        body {
            font-family: 'Courier Prime', monospace;
            background-color: #0a0a0a;
            color: #e0e0e0;
            padding-top: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            background: #050505;
            border: 2px solid #222;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.15), inset 0 0 60px rgba(0,0,0,0.5);
        }

        #hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #1a1a1a;
            background: linear-gradient(180deg, #0a0a0a 0%, #000 100%);
            font-size: 12px;
        }

        .fighter-info {
            width: 42%;
        }

        .fighter-name {
            font-size: 10px;
            color: #666;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .fighter-name.player { color: #ff4444; }
        .fighter-name.enemy { color: #7ec8e3; text-align: right; }

        .hp-bar {
            height: 8px;
            background: #111;
            border: 1px solid #333;
            position: relative;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000 0%, #ff4444 100%);
            width: 100%;
            transition: width 0.3s ease-out;
            position: relative;
        }

        .hp-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3) 0%, transparent 100%);
        }

        .hp-fill.enemy {
            background: linear-gradient(90deg, #4a9ebe 0%, #7ec8e3 100%);
        }

        .stamina-bar {
            height: 3px;
            background: #111;
            margin-top: 3px;
        }

        .stamina-fill {
            height: 100%;
            background: #00ff88;
            width: 100%;
            transition: width 0.15s;
        }

        .stamina-fill.low { background: #ff6600; }

        .center-info {
            text-align: center;
            width: 16%;
        }

        .level-badge {
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 1px solid #333;
            padding: 4px 8px;
            font-size: 10px;
            color: #00ffff;
        }

        .credits-display {
            margin-top: 4px;
            font-size: 9px;
            color: #ffd700;
        }

        canvas {
            display: block;
            width: 100%;
            height: 320px;
            background: #000;
        }

        .combo-display {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: bold;
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        .combo-display.active {
            opacity: 1;
            animation: comboPulse 0.3s ease-out;
        }

        @keyframes comboPulse {
            0% { transform: translateX(-50%) scale(1.5); }
            100% { transform: translateX(-50%) scale(1); }
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .hidden { display: none !important; }

        h1 {
            color: #ff0000;
            margin: 0 0 5px 0;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-size: 28px;
            text-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
        }

        .subtitle {
            color: #00ffff;
            font-size: 10px;
            letter-spacing: 3px;
            margin-bottom: 25px;
        }

        h2 {
            color: #00ffff;
            margin: 0 0 15px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        p { margin-bottom: 15px; line-height: 1.5; font-size: 13px; }

        .controls-hint {
            font-size: 11px;
            color: #555;
            margin-top: 10px;
            line-height: 1.6;
        }

        .controls-hint span {
            color: #888;
        }

        button {
            background: linear-gradient(180deg, #cc0000 0%, #990000 100%);
            color: #fff;
            border: none;
            padding: 14px 28px;
            font-family: 'Courier Prime', monospace;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin: 6px;
            text-transform: uppercase;
            letter-spacing: 2px;
            min-height: 44px;
            min-width: 140px;
            border: 1px solid #ff2222;
            box-shadow: 0 4px 15px rgba(255, 0, 0, 0.3), inset 0 1px 0 rgba(255,255,255,0.2);
            transition: all 0.15s;
        }

        button:hover {
            background: linear-gradient(180deg, #ff0000 0%, #cc0000 100%);
            box-shadow: 0 4px 25px rgba(255, 0, 0, 0.5);
        }

        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 10px rgba(255, 0, 0, 0.3);
        }

        button.secondary {
            background: linear-gradient(180deg, #222 0%, #111 100%);
            border-color: #444;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        button.secondary:hover {
            background: linear-gradient(180deg, #333 0%, #222 100%);
            border-color: #00ffff;
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.2);
        }

        button:disabled {
            background: #1a1a1a;
            color: #444;
            border-color: #333;
            box-shadow: none;
            cursor: not-allowed;
        }

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            max-width: 280px;
        }

        .skin-item {
            border: 2px solid #222;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: #0a0a0a;
        }

        .skin-item:hover {
            border-color: #444;
        }

        .skin-item.selected {
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .skin-preview {
            width: 100%;
            height: 25px;
            margin-bottom: 6px;
            position: relative;
            overflow: hidden;
        }

        .skin-preview::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.2) 50%, transparent 100%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .skin-name {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .skin-price {
            font-size: 10px;
            color: #ffd700;
            margin-top: 3px;
        }

        .skin-owned {
            color: #00ff88;
            font-size: 9px;
            margin-top: 3px;
        }

        .mobile-controls {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            max-width: 180px;
            padding-bottom: 20px;
        }

        .control-btn {
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 2px solid #333;
            color: #00ffff;
            height: 56px;
            width: 56px;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            box-shadow: 0 4px 0 #000, 0 0 15px rgba(0, 255, 255, 0.1);
            transition: all 0.1s;
            position: relative;
        }

        .control-btn::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
        }

        .control-btn[data-dir="up"]::before {
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 14px solid #00ffff;
        }

        .control-btn[data-dir="down"]::before {
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 14px solid #00ffff;
        }

        .control-btn[data-dir="left"]::before {
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-right: 14px solid #00ffff;
        }

        .control-btn[data-dir="right"]::before {
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-left: 14px solid #00ffff;
        }

        .control-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #000, 0 0 20px rgba(0, 255, 255, 0.3);
            background: linear-gradient(180deg, #222 0%, #1a1a1a 100%);
            border-color: #00ffff;
        }

        .control-btn.empty {
            pointer-events: none;
            border: none;
            background: transparent;
            box-shadow: none;
        }

        .action-hint {
            position: absolute;
            bottom: 3px;
            font-size: 7px;
            color: #555;
            letter-spacing: 0.5px;
        }

        @media (min-width: 768px) {
            #game-container {
                margin-top: 20px;
                border-radius: 4px;
            }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-link" aria-label="Back to home"></a>

    <div id="game-container">
        <div id="hud">
            <div class="fighter-info">
                <div class="fighter-name player">DUELIST <span id="level-display">1</span></div>
                <div class="hp-bar"><div id="player-hp" class="hp-fill"></div></div>
                <div class="stamina-bar"><div id="player-stamina" class="stamina-fill"></div></div>
            </div>
            <div class="center-info">
                <div class="level-badge">VS</div>
                <div class="credits-display"><span id="credits-display">0</span> CR</div>
            </div>
            <div class="fighter-info">
                <div class="fighter-name enemy">SITH LVL <span id="enemy-level">1</span></div>
                <div class="hp-bar"><div id="enemy-hp" class="hp-fill enemy"></div></div>
                <div class="stamina-bar"><div id="enemy-stamina" class="stamina-fill"></div></div>
            </div>
        </div>

        <canvas id="gameCanvas" width="400" height="320"></canvas>
        <div class="combo-display" id="combo-display"></div>

        <div id="start-screen" class="overlay">
            <h1>NEON DUEL</h1>
            <div class="subtitle">LIGHTSABER COMBAT SIMULATOR</div>
            <p>Master timing. Counter attacks. Defeat the Sith.</p>
            <button id="btn-start">ENGAGE</button>
            <button id="btn-shop" class="secondary">ARMORY</button>
            <div class="controls-hint">
                <span>←→</span> Move &nbsp; <span>↑</span> Strike &nbsp; <span>↓</span> Block<br>
                Block enemy attack to counter!
            </div>
        </div>

        <div id="shop-screen" class="overlay hidden">
            <h2>ARMORY</h2>
            <p>Balance: <span id="shop-credits" style="color:#ffd700">0</span> CR</p>
            <div class="shop-grid" id="skin-grid"></div>
            <button id="btn-close-shop" class="secondary">RETURN</button>
        </div>

        <div id="game-over-screen" class="overlay hidden">
            <h2 id="end-title">VICTORY</h2>
            <p id="end-msg">Enemy Eliminated</p>
            <p>Reward: <span id="reward-amt" style="color:#ffd700">50</span> CR</p>
            <button id="btn-next">CONTINUE</button>
            <button id="btn-restart" class="hidden">RETRY</button>
            <button id="btn-menu" class="secondary">MENU</button>
        </div>
    </div>

    <div class="mobile-controls">
        <div class="control-btn empty"></div>
        <button class="control-btn" data-dir="up"><span class="action-hint">STRIKE</span></button>
        <div class="control-btn empty"></div>
        <button class="control-btn" data-dir="left"></button>
        <button class="control-btn" data-dir="down"><span class="action-hint">BLOCK</span></button>
        <button class="control-btn" data-dir="right"></button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const SKINS = [
            { id: 'red', color: '#ff0000', glow: '#ff4444', cost: 0, name: 'Crimson' },
            { id: 'blue', color: '#00aaff', glow: '#66ccff', cost: 100, name: 'Azure' },
            { id: 'green', color: '#00ff44', glow: '#66ff88', cost: 250, name: 'Emerald' },
            { id: 'purple', color: '#aa00ff', glow: '#cc66ff', cost: 500, name: 'Void' },
            { id: 'gold', color: '#ffaa00', glow: '#ffcc44', cost: 1000, name: 'Solar' },
            { id: 'white', color: '#ffffff', glow: '#ffffff', cost: 2000, name: 'Pure' }
        ];

        const ENEMY_COLORS = [
            { color: '#7ec8e3', glow: '#a0d8f0' },
            { color: '#ff4444', glow: '#ff6666' },
            { color: '#aa00ff', glow: '#cc44ff' }
        ];

        let gameState = {
            credits: parseInt(localStorage.getItem('noir_saber_credits')) || 0,
            unlockedSkins: JSON.parse(localStorage.getItem('noir_saber_skins')) || ['red'],
            currentSkin: localStorage.getItem('noir_saber_current') || 'red',
            level: parseInt(localStorage.getItem('noir_saber_level')) || 1,
            status: 'START',
            combo: 0,
            comboTimer: 0
        };

        let player = {
            x: 80, y: 220, w: 24, h: 60,
            hp: 100, maxHp: 100,
            stamina: 100, maxStamina: 100,
            facing: 1, state: 'idle', stateTimer: 0,
            color: '#ff0000', glow: '#ff4444',
            velocityX: 0, canCounter: false, counterWindow: 0,
            attackCooldown: 0, blockStun: 0
        };

        let enemy = {
            x: 280, y: 220, w: 24, h: 60,
            hp: 100, maxHp: 100,
            stamina: 100, maxStamina: 100,
            facing: -1, state: 'idle', stateTimer: 0,
            aiTimer: 0, aiState: 'approach',
            color: '#7ec8e3', glow: '#a0d8f0',
            attackCooldown: 0, blockStun: 0,
            pattern: 0, patternStep: 0
        };

        let particles = [];
        let sparks = [];
        let shake = 0;
        let slowMo = 0;
        let flashAlpha = 0;

        const ui = {
            start: document.getElementById('start-screen'),
            shop: document.getElementById('shop-screen'),
            gameOver: document.getElementById('game-over-screen'),
            playerHp: document.getElementById('player-hp'),
            enemyHp: document.getElementById('enemy-hp'),
            playerStamina: document.getElementById('player-stamina'),
            enemyStamina: document.getElementById('enemy-stamina'),
            credits: document.getElementById('credits-display'),
            level: document.getElementById('level-display'),
            enemyLevel: document.getElementById('enemy-level'),
            shopCredits: document.getElementById('shop-credits'),
            skinGrid: document.getElementById('skin-grid'),
            endTitle: document.getElementById('end-title'),
            endMsg: document.getElementById('end-msg'),
            reward: document.getElementById('reward-amt'),
            btnNext: document.getElementById('btn-next'),
            btnRestart: document.getElementById('btn-restart'),
            comboDisplay: document.getElementById('combo-display')
        };

        function init() {
            const skin = SKINS.find(s => s.id === gameState.currentSkin);
            player.color = skin.color;
            player.glow = skin.glow;
            updateUI();
            renderShop();
            requestAnimationFrame(gameLoop);
        }

        function saveGame() {
            localStorage.setItem('noir_saber_credits', gameState.credits);
            localStorage.setItem('noir_saber_skins', JSON.stringify(gameState.unlockedSkins));
            localStorage.setItem('noir_saber_current', gameState.currentSkin);
            localStorage.setItem('noir_saber_level', gameState.level);
        }

        function updateUI() {
            ui.credits.textContent = gameState.credits;
            ui.level.textContent = gameState.level;
            ui.enemyLevel.textContent = gameState.level;
            ui.playerHp.style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
            ui.enemyHp.style.width = `${Math.max(0, (enemy.hp / enemy.maxHp) * 100)}%`;
            ui.playerStamina.style.width = `${(player.stamina / player.maxStamina) * 100}%`;
            ui.enemyStamina.style.width = `${(enemy.stamina / enemy.maxStamina) * 100}%`;

            ui.playerStamina.classList.toggle('low', player.stamina < 30);
            ui.enemyStamina.classList.toggle('low', enemy.stamina < 30);

            if (gameState.combo > 1) {
                ui.comboDisplay.textContent = `${gameState.combo}x COMBO`;
                ui.comboDisplay.classList.add('active');
            } else {
                ui.comboDisplay.classList.remove('active');
            }
        }

        function startLevel() {
            gameState.status = 'PLAYING';
            gameState.combo = 0;

            player.hp = player.maxHp;
            player.stamina = player.maxStamina;
            player.x = 80;
            player.state = 'idle';
            player.stateTimer = 0;
            player.attackCooldown = 0;
            player.blockStun = 0;
            player.canCounter = false;

            const enemyColor = ENEMY_COLORS[gameState.level % ENEMY_COLORS.length];
            enemy.color = enemyColor.color;
            enemy.glow = enemyColor.glow;
            enemy.maxHp = 80 + (gameState.level * 25);
            enemy.hp = enemy.maxHp;
            enemy.stamina = enemy.maxStamina;
            enemy.x = 280;
            enemy.state = 'idle';
            enemy.stateTimer = 0;
            enemy.aiState = 'approach';
            enemy.aiTimer = 60;
            enemy.attackCooldown = 0;
            enemy.pattern = Math.floor(Math.random() * 3);
            enemy.patternStep = 0;

            particles = [];
            sparks = [];

            ui.start.classList.add('hidden');
            ui.shop.classList.add('hidden');
            ui.gameOver.classList.add('hidden');
            updateUI();
        }

        function spawnParticles(x, y, color, count = 12, spread = 8) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                const speed = 2 + Math.random() * spread;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 2,
                    life: 1.0,
                    color,
                    size: 2 + Math.random() * 3
                });
            }
        }

        function spawnSparks(x, y, count = 20) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 8;
                sparks.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 4,
                    life: 0.5 + Math.random() * 0.5,
                    color: Math.random() > 0.5 ? '#ffffff' : '#ffff00'
                });
            }
        }

        function showCombo() {
            gameState.combo++;
            gameState.comboTimer = 120;
            updateUI();
        }

        function handleInput(dir) {
            if (gameState.status !== 'PLAYING') return;
            if (player.blockStun > 0) return;

            const speed = 4;

            if (dir === 'left') {
                player.velocityX = -speed;
                player.facing = -1;
            } else if (dir === 'right') {
                player.velocityX = speed;
                player.facing = 1;
            } else if (dir === 'up' && player.attackCooldown <= 0 && player.stamina >= 15) {
                if (player.canCounter && player.counterWindow > 0) {
                    // Counter attack - powerful!
                    player.state = 'counter';
                    player.stateTimer = 25;
                    player.stamina -= 10;
                    player.attackCooldown = 20;

                    const dist = Math.abs(player.x - enemy.x);
                    if (dist < 80) {
                        const damage = 35 + gameState.level * 3;
                        enemy.hp -= damage;
                        enemy.blockStun = 30;
                        shake = 12;
                        slowMo = 8;
                        flashAlpha = 0.4;
                        spawnParticles(enemy.x + 12, enemy.y + 25, '#ffffff', 20, 12);
                        spawnSparks((player.x + enemy.x) / 2, 200, 30);
                        showCombo();
                        if (enemy.hp <= 0) endLevel(true);
                    }
                    player.canCounter = false;
                } else {
                    // Normal attack
                    player.state = 'attack';
                    player.stateTimer = 18;
                    player.stamina -= 15;
                    player.attackCooldown = 25;

                    setTimeout(() => {
                        if (gameState.status !== 'PLAYING') return;
                        const dist = Math.abs(player.x - enemy.x);
                        if (dist < 70) {
                            if (enemy.state === 'block' && enemy.stamina > 0) {
                                // Blocked
                                spawnSparks((player.x + enemy.x) / 2, 200, 15);
                                shake = 3;
                                enemy.stamina -= 20;
                            } else {
                                // Hit!
                                const damage = 18 + Math.floor(gameState.combo * 2);
                                enemy.hp -= damage;
                                shake = 6;
                                spawnParticles(enemy.x + 12, enemy.y + 25, enemy.color, 15);
                                showCombo();
                                if (enemy.hp <= 0) endLevel(true);
                            }
                        }
                        updateUI();
                    }, 80);
                }
            } else if (dir === 'down' && player.stamina >= 5) {
                player.state = 'block';
                player.stateTimer = 25;
                player.stamina -= 5;
            }
            updateUI();
        }

        function handleInputUp(dir) {
            if (dir === 'left' && player.velocityX < 0) player.velocityX = 0;
            if (dir === 'right' && player.velocityX > 0) player.velocityX = 0;
        }

        function updateAI() {
            if (enemy.hp <= 0 || enemy.blockStun > 0) return;

            enemy.aiTimer--;

            // Regenerate stamina
            if (enemy.state === 'idle' && enemy.stamina < enemy.maxStamina) {
                enemy.stamina = Math.min(enemy.maxStamina, enemy.stamina + 0.3);
            }

            const dist = Math.abs(player.x - enemy.x);
            const speedMod = 1 + gameState.level * 0.1;

            if (enemy.state !== 'idle') {
                enemy.stateTimer--;
                if (enemy.stateTimer <= 0) {
                    enemy.state = 'idle';
                    enemy.aiTimer = 20 + Math.random() * 20;
                }
                return;
            }

            if (enemy.attackCooldown > 0) {
                enemy.attackCooldown--;
                return;
            }

            // Pattern-based AI
            if (enemy.aiTimer <= 0) {
                if (dist < 75) {
                    // Combat range
                    const patterns = [
                        ['attack', 'attack', 'block'],
                        ['block', 'attack', 'attack'],
                        ['attack', 'block', 'attack']
                    ];
                    const pattern = patterns[enemy.pattern];
                    const action = pattern[enemy.patternStep % pattern.length];

                    if (player.state === 'attack' && Math.random() < 0.4 + gameState.level * 0.05) {
                        // React to player attack
                        enemy.state = 'block';
                        enemy.stateTimer = 20;
                        enemy.stamina -= 10;
                    } else if (action === 'attack' && enemy.stamina >= 20) {
                        enemy.state = 'attack';
                        enemy.stateTimer = 22 - Math.min(8, gameState.level);
                        enemy.stamina -= 20;
                        enemy.attackCooldown = 30;

                        setTimeout(() => {
                            if (gameState.status !== 'PLAYING' || enemy.hp <= 0) return;
                            const currentDist = Math.abs(player.x - enemy.x);
                            if (currentDist < 75) {
                                if (player.state === 'block' && player.stamina > 0) {
                                    spawnSparks((player.x + enemy.x) / 2, 200, 15);
                                    shake = 3;
                                    player.stamina -= 15;
                                    player.canCounter = true;
                                    player.counterWindow = 20;
                                } else if (player.state !== 'block') {
                                    const damage = 12 + gameState.level * 2;
                                    player.hp -= damage;
                                    shake = 8;
                                    gameState.combo = 0;
                                    spawnParticles(player.x + 12, player.y + 25, player.color, 12);
                                    if (player.hp <= 0) endLevel(false);
                                }
                                updateUI();
                            }
                        }, 100);
                    } else if (action === 'block') {
                        enemy.state = 'block';
                        enemy.stateTimer = 25;
                        enemy.stamina -= 10;
                    }

                    enemy.patternStep++;
                    enemy.aiTimer = (35 - gameState.level * 2) + Math.random() * 20;
                } else {
                    // Approach
                    const moveDir = player.x < enemy.x ? -1 : 1;
                    enemy.x += moveDir * (2 + speedMod);
                    enemy.facing = moveDir;
                    enemy.aiTimer = 5;
                }
            }
        }

        function endLevel(victory) {
            gameState.status = 'GAMEOVER';
            slowMo = 15;

            setTimeout(() => {
                ui.gameOver.classList.remove('hidden');
                if (victory) {
                    ui.endTitle.textContent = "VICTORY";
                    ui.endTitle.style.color = "#00ffff";
                    ui.endMsg.textContent = gameState.combo > 5 ? `${gameState.combo}x Combo Master!` : `Sith Eliminated`;
                    const reward = 40 + (gameState.level * 15) + (gameState.combo * 5);
                    ui.reward.textContent = reward;
                    gameState.credits += reward;
                    gameState.level++;
                    ui.btnNext.classList.remove('hidden');
                    ui.btnRestart.classList.add('hidden');
                } else {
                    ui.endTitle.textContent = "DEFEATED";
                    ui.endTitle.style.color = "#ff0000";
                    ui.endMsg.textContent = "The dark side prevails...";
                    ui.reward.textContent = "5";
                    gameState.credits += 5;
                    ui.btnNext.classList.add('hidden');
                    ui.btnRestart.classList.remove('hidden');
                }
                saveGame();
                updateUI();
            }, 600);
        }

        function drawFighter(f, isPlayer) {
            ctx.save();
            ctx.translate(f.x + f.w / 2, f.y);
            if (f.facing === -1) ctx.scale(-1, 1);

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath();
            ctx.ellipse(0, 55, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body
            ctx.strokeStyle = isPlayer ? '#ff4444' : '#4a9ebe';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            // Head
            ctx.beginPath();
            ctx.arc(0, -35, 8, 0, Math.PI * 2);
            ctx.stroke();

            // Torso
            ctx.beginPath();
            ctx.moveTo(0, -27);
            ctx.lineTo(0, 0);
            ctx.stroke();

            // Arms
            ctx.beginPath();
            if (f.state === 'attack' || f.state === 'counter') {
                ctx.moveTo(0, -20);
                ctx.lineTo(15, -30);
            } else if (f.state === 'block') {
                ctx.moveTo(0, -20);
                ctx.lineTo(12, -15);
            } else {
                ctx.moveTo(0, -20);
                ctx.lineTo(10, -10);
            }
            ctx.stroke();

            // Legs
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-8, 30);
            ctx.moveTo(0, 0);
            ctx.lineTo(8, 30);
            ctx.stroke();

            // Lightsaber
            let saberX = 10, saberY = -10, rotation = 0.3;
            let bladeLen = 45;

            if (f.state === 'attack') {
                rotation = -0.8;
                saberY = -35;
                saberX = 15;
                bladeLen = 55;
            } else if (f.state === 'counter') {
                rotation = -1.2;
                saberY = -40;
                saberX = 15;
                bladeLen = 60;
            } else if (f.state === 'block') {
                rotation = 1.8;
                saberX = 12;
                saberY = -15;
            }

            ctx.save();
            ctx.translate(saberX, saberY);
            ctx.rotate(rotation);

            // Hilt
            ctx.fillStyle = '#333';
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.fillRect(-2, 0, 4, 14);
            ctx.strokeRect(-2, 0, 4, 14);

            // Blade glow (outer)
            ctx.shadowBlur = 25;
            ctx.shadowColor = f.glow;
            ctx.fillStyle = f.glow;
            ctx.globalAlpha = 0.4;
            ctx.fillRect(-3, -bladeLen, 6, bladeLen);

            // Blade core
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 15;
            ctx.fillStyle = f.color;
            ctx.fillRect(-1.5, -bladeLen, 3, bladeLen);

            // Blade white core
            ctx.fillStyle = '#fff';
            ctx.globalAlpha = 0.7;
            ctx.fillRect(-0.5, -bladeLen + 2, 1, bladeLen - 4);

            ctx.restore();
            ctx.restore();
        }

        function drawEnvironment() {
            // Atmospheric fog
            const gradient = ctx.createRadialGradient(200, 160, 50, 200, 160, 250);
            gradient.addColorStop(0, 'rgba(20, 20, 30, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid floor
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.08)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width + 100; i += 30) {
                ctx.beginPath();
                ctx.moveTo(i, 260);
                ctx.lineTo(i - 60, 320);
                ctx.stroke();
            }
            for (let j = 260; j < 320; j += 15) {
                ctx.beginPath();
                ctx.moveTo(0, j);
                ctx.lineTo(400, j);
                ctx.stroke();
            }

            // Floor line
            ctx.strokeStyle = '#00ffff';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#00ffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 260);
            ctx.lineTo(400, 260);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        let lastTime = 0;
        function gameLoop(time) {
            const delta = Math.min(32, time - lastTime);
            lastTime = time;

            const speedMult = slowMo > 0 ? 0.3 : 1;
            if (slowMo > 0) slowMo--;

            // Clear
            ctx.fillStyle = '#050508';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Screen shake
            if (shake > 0) {
                ctx.save();
                ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);
                shake *= 0.85;
                if (shake < 0.3) shake = 0;
            }

            drawEnvironment();

            // Update game state
            if (gameState.status === 'PLAYING') {
                // Player movement
                player.x += player.velocityX * speedMult;
                player.x = Math.max(20, Math.min(canvas.width - 40, player.x));

                // Counter window
                if (player.counterWindow > 0) {
                    player.counterWindow--;
                    if (player.counterWindow <= 0) player.canCounter = false;
                }

                // Stamina regen
                if (player.state === 'idle' && player.stamina < player.maxStamina) {
                    player.stamina = Math.min(player.maxStamina, player.stamina + 0.4);
                }

                // Block stun
                if (player.blockStun > 0) player.blockStun--;
                if (enemy.blockStun > 0) enemy.blockStun--;

                // Attack cooldowns
                if (player.attackCooldown > 0) player.attackCooldown--;
                if (enemy.attackCooldown > 0) enemy.attackCooldown--;

                // State timers
                if (player.stateTimer > 0) {
                    player.stateTimer--;
                } else if (player.state !== 'idle') {
                    player.state = 'idle';
                }

                // Combo timer
                if (gameState.comboTimer > 0) {
                    gameState.comboTimer--;
                    if (gameState.comboTimer <= 0) {
                        gameState.combo = 0;
                        updateUI();
                    }
                }

                updateAI();
            }

            // Draw fighters
            drawFighter(player, true);
            drawFighter(enemy, false);

            // Counter indicator
            if (player.canCounter && player.counterWindow > 0) {
                ctx.fillStyle = '#ffff00';
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.02) * 0.3;
                ctx.font = 'bold 12px Courier Prime';
                ctx.textAlign = 'center';
                ctx.fillText('COUNTER!', player.x + 12, player.y - 50);
                ctx.globalAlpha = 1;
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx * speedMult;
                p.y += p.vy * speedMult;
                p.vy += 0.2;
                p.life -= 0.03;

                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.shadowBlur = 5;
                ctx.shadowColor = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;

                if (p.life <= 0) particles.splice(i, 1);
            }

            // Sparks
            for (let i = sparks.length - 1; i >= 0; i--) {
                let s = sparks[i];
                s.x += s.vx * speedMult;
                s.y += s.vy * speedMult;
                s.vy += 0.3;
                s.life -= 0.04;

                ctx.strokeStyle = s.color;
                ctx.globalAlpha = s.life;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(s.x, s.y);
                ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;

                if (s.life <= 0) sparks.splice(i, 1);
            }

            // Flash effect
            if (flashAlpha > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                flashAlpha *= 0.85;
            }

            if (shake > 0) ctx.restore();

            requestAnimationFrame(gameLoop);
        }

        function renderShop() {
            ui.skinGrid.innerHTML = '';
            ui.shopCredits.textContent = gameState.credits;

            SKINS.forEach(skin => {
                const el = document.createElement('div');
                el.className = `skin-item ${gameState.currentSkin === skin.id ? 'selected' : ''}`;
                const owned = gameState.unlockedSkins.includes(skin.id);

                el.innerHTML = `
                    <div class="skin-preview" style="background: linear-gradient(90deg, ${skin.color} 0%, ${skin.glow} 100%); box-shadow: 0 0 15px ${skin.color}"></div>
                    <div class="skin-name">${skin.name}</div>
                    ${owned
                        ? `<div class="skin-owned">EQUIPPED</div>`
                        : `<div class="skin-price">${skin.cost} CR</div>`
                    }
                `;

                el.onclick = () => {
                    if (owned) {
                        gameState.currentSkin = skin.id;
                        player.color = skin.color;
                        player.glow = skin.glow;
                        saveGame();
                        renderShop();
                    } else if (gameState.credits >= skin.cost) {
                        gameState.credits -= skin.cost;
                        gameState.unlockedSkins.push(skin.id);
                        gameState.currentSkin = skin.id;
                        player.color = skin.color;
                        player.glow = skin.glow;
                        saveGame();
                        renderShop();
                        updateUI();
                    } else {
                        el.style.borderColor = '#ff0000';
                        setTimeout(() => el.style.borderColor = '#222', 300);
                    }
                };
                ui.skinGrid.appendChild(el);
            });
        }

        // Event Listeners
        document.getElementById('btn-start').onclick = startLevel;
        document.getElementById('btn-next').onclick = startLevel;
        document.getElementById('btn-restart').onclick = startLevel;

        document.getElementById('btn-shop').onclick = () => {
            ui.start.classList.add('hidden');
            ui.shop.classList.remove('hidden');
            renderShop();
        };

        document.getElementById('btn-close-shop').onclick = () => {
            ui.shop.classList.add('hidden');
            ui.start.classList.remove('hidden');
        };

        document.getElementById('btn-menu').onclick = () => {
            ui.gameOver.classList.add('hidden');
            ui.start.classList.remove('hidden');
        };

        // Keyboard
        const keysDown = new Set();
        window.addEventListener('keydown', (e) => {
            if (keysDown.has(e.key)) return;
            keysDown.add(e.key);

            if (e.key === 'ArrowLeft' || e.key === 'a') handleInput('left');
            if (e.key === 'ArrowRight' || e.key === 'd') handleInput('right');
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') handleInput('up');
            if (e.key === 'ArrowDown' || e.key === 's') handleInput('down');
        });

        window.addEventListener('keyup', (e) => {
            keysDown.delete(e.key);
            if (e.key === 'ArrowLeft' || e.key === 'a') handleInputUp('left');
            if (e.key === 'ArrowRight' || e.key === 'd') handleInputUp('right');
        });

        // Touch controls
        document.querySelectorAll('.control-btn[data-dir]').forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleInput(btn.dataset.dir);
            }, { passive: false });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                handleInputUp(btn.dataset.dir);
            }, { passive: false });

            btn.addEventListener('mousedown', () => handleInput(btn.dataset.dir));
            btn.addEventListener('mouseup', () => handleInputUp(btn.dataset.dir));
            btn.addEventListener('mouseleave', () => handleInputUp(btn.dataset.dir));
        });

        init();
    </script>
</body>
</html>
