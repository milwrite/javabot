<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saber Duel - Bot Sportello</title>
    <link rel="stylesheet" href="../page-theme.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap" rel="stylesheet">
    <style>
        :root {
            --noir-bg: #0a0a0a;
            --noir-accent: #7ec8e3;
            --noir-red: #ff0000;
            --noir-cyan: #00ffff;
            --font-main: 'Courier Prime', monospace;
        }

        body {
            background-color: var(--noir-bg);
            color: var(--noir-cyan);
            font-family: var(--font-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
            /* padding-top 80px required by prompt */
            padding-top: 80px; 
            margin: 0;
            overflow-x: hidden;
        }

        /* Game Container */
        .game-wrapper {
            width: 100%;
            max-width: 400px;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* HUD */
        .hud {
            width: 100%;
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9rem;
        }

        .health-bar-container {
            width: 45%;
            height: 20px;
            border: 1px solid var(--noir-accent);
            position: relative;
        }

        .health-fill {
            height: 100%;
            background-color: var(--noir-cyan);
            width: 100%;
            transition: width 0.2s ease;
        }

        .enemy-health .health-fill {
            background-color: var(--noir-red);
        }

        /* Canvas */
        canvas {
            background-color: #111;
            border: 2px solid var(--noir-accent);
            box-shadow: 0 0 10px rgba(126, 200, 227, 0.2);
            display: block;
            width: 100%;
            /* Maintain aspect ratio logic in JS, max height constraint */
            max-height: 50vh; 
            image-rendering: pixelated;
        }

        /* Overlay Messages */
        .game-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(10, 10, 10, 0.9);
            padding: 20px;
            border: 1px solid var(--noir-cyan);
            display: none; /* Toggled via JS */
            z-index: 10;
            width: 80%;
        }

        .game-overlay h2 {
            margin-top: 0;
            color: var(--noir-accent);
            text-shadow: 0 0 5px var(--noir-accent);
        }

        .game-overlay button {
            background: transparent;
            border: 1px solid var(--noir-red);
            color: var(--noir-red);
            padding: 10px 20px;
            font-family: var(--font-main);
            cursor: pointer;
            margin-top: 10px;
            font-size: 1rem;
            text-transform: uppercase;
        }

        .game-overlay button:hover {
            background: var(--noir-red);
            color: var(--noir-bg);
        }

        /* Mobile Controls */
        .controls-area {
            margin-top: 20px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .mobile-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 180px;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            background: #1a1a1a;
            border: 1px solid var(--noir-accent);
            color: var(--noir-accent);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation; /* Improves touch response */
        }

        .control-btn:active {
            background: var(--noir-accent);
            color: var(--noir-bg);
        }

        .control-btn.empty {
            border: none;
            background: transparent;
            pointer-events: none;
        }

        /* Action Button specific styling */
        .action-container {
            display: flex;
            justify-content: center;
        }

        .action-btn {
            width: 80px;
            height: 60px;
            background: #1a1a1a;
            border: 2px solid var(--noir-red);
            color: var(--noir-red);
            border-radius: 50%;
            font-family: var(--font-main);
            font-weight: bold;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .action-btn:active {
            background: var(--noir-red);
            color: var(--noir-bg);
        }

        /* Instructions */
        .instructions {
            font-size: 0.75rem;
            color: #888;
            margin-top: 10px;
            text-align: center;
            max-width: 300px;
        }

        @media (min-width: 768px) {
            .controls-area {
                display: none; /* Hide touch controls on desktop */
            }
            .instructions::after {
                content: " (Use Arrow Keys to Move, Space to Attack)";
            }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-link" aria-label="Back to home"></a>

    <div class="game-wrapper">
        <div class="hud">
            <div class="health-bar-container player-health">
                <div class="health-fill" id="player-hp"></div>
            </div>
            <div class="health-bar-container enemy-health">
                <div class="health-fill" id="enemy-hp"></div>
            </div>
        </div>

        <div style="position: relative; width: 100%;">
            <canvas id="gameCanvas" width="400" height="400"></canvas>
            
            <div id="start-screen" class="game-overlay" style="display: block;">
                <h2>SABER DUEL</h2>
                <p>Defeat the rouge AI.</p>
                <button onclick="startGame()">Initialize</button>
            </div>

            <div id="game-over-screen" class="game-overlay">
                <h2 id="end-title">TERMINATED</h2>
                <p id="end-score">Score: 0</p>
                <button onclick="resetGame()">Reboot</button>
            </div>
        </div>

        <div class="controls-area">
            <div class="mobile-controls">
                <div class="control-btn empty"></div>
                <button class="control-btn" data-dir="up">▲</button>
                <div class="control-btn empty"></div>
                <button class="control-btn" data-dir="left">◀</button>
                <button class="control-btn" data-dir="down">▼</button>
                <button class="control-btn" data-dir="right">▶</button>
            </div>
            <div class="action-container">
                <button class="control-btn action-btn" id="btn-attack">ATTACK</button>
            </div>
            <p class="instructions">Tap controls to move and strike.</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const playerHpEl = document.getElementById('player-hp');
        const enemyHpEl = document.getElementById('enemy-hp');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const endTitle = document.getElementById('end-title');
        const endScore = document.getElementById('end-score');

        // Game Constants
        const PLAYER_COLOR = '#00ffff';
        const ENEMY_COLOR = '#ff0000';
        const SABER_COLOR = '#7ec8e3';
        const SPEED = 3;
        const SIZE = 30;
        const SABER_RANGE = 50;
        const SABER_WIDTH = 40;
        const COOLDOWN = 30; // Frames

        // Game State
        let gameRunning = false;
        let score = 0;
        let keys = {};
        
        // Entities
        let player = {
            x: 50, y: 200, hp: 100, maxHp: 100,
            vx: 0, vy: 0, cooldown: 0,
            dir: 1 // 1 right, -1 left
        };
        
        let enemy = {
            x: 350, y: 200, hp: 100, maxHp: 100,
            vx: 0, vy: 0, cooldown: 0,
            dir: -1,
            state: 'chase', // chase, attack, retreat
            timer: 0
        };

        // Input Handling
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if(e.code === 'Space' && gameRunning) handleAttack();
        });

        window.addEventListener('keyup', (e) => keys[e.code] = false);

        // Mobile Controls Logic
        function handleDirection(dir) {
            if (!gameRunning) return;
            
            switch(dir) {
                case 'up': player.vy = -SPEED; break;
                case 'down': player.vy = SPEED; break;
                case 'left': player.vx = -SPEED; player.dir = -1; break;
                case 'right': player.vx = SPEED; player.dir = 1; break;
            }
            
            // Stop movement after a short burst for D-Pad feel, or keep moving?
            // For arcade feel, let's keep moving until released or changed.
            // But since touchstart is momentary, we need a way to stop.
            // Simplification: Tap to move a step, or hold logic.
            // Implementing simple "move while pressed" logic via touchstart/touchend
        }

        // Enhanced Touch Logic for continuous movement
        document.querySelectorAll('.control-btn[data-dir]').forEach(btn => {
            const dir = btn.dataset.dir;
            
            btn.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                if (!gameRunning) return;
                
                if (dir === 'up') player.vy = -SPEED;
                if (dir === 'down') player.vy = SPEED;
                if (dir === 'left') { player.vx = -SPEED; player.dir = -1; }
                if (dir === 'right') { player.vx = SPEED; player.dir = 1; }
            }, { passive: false });

            btn.addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                // Stop movement in that axis
                if (dir === 'up' || dir === 'down') player.vy = 0;
                if (dir === 'left' || dir === 'right') player.vx = 0;
            }, { passive: false });
        });

        const attackBtn = document.getElementById('btn-attack');
        attackBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) handleAttack();
        }, { passive: false });

        function handleAttack() {
            if (player.cooldown > 0) return;
            
            player.cooldown = COOLDOWN;
            
            // Hitbox calculation
            const hitX = player.dir === 1 ? player.x + SIZE : player.x - SABER_WIDTH;
            const hitY = player.y;
            const hitW = SABER_WIDTH;
            const hitH = SIZE;

            // Check collision with enemy
            if (rectIntersect(hitX, hitY, hitW, hitH, enemy.x, enemy.y, SIZE, SIZE)) {
                enemy.hp -= 10;
                enemy.x += player.dir * 10; // Knockback
                shakeScreen();
                if (enemy.hp <= 0) endGame(true);
            }
        }

        function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
        }

        function startGame() {
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            resetEntities();
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            startGame();
        }

        function resetEntities() {
            player.x = 50; player.y = 200; player.hp = 100; player.cooldown = 0;
            enemy.x = 350; enemy.y = 200; enemy.hp = 100; enemy.cooldown = 0;
            score = 0;
            updateHealthUI();
        }

        function updateHealthUI() {
            playerHpEl.style.width = Math.max(0, (player.hp / player.maxHp) * 100) + '%';
            enemyHpEl.style.width = Math.max(0, (enemy.hp / enemy.maxHp) * 100) + '%';
        }

        function endGame(victory) {
            gameRunning = false;
            gameOverScreen.style.display = 'block';
            if (victory) {
                endTitle.innerText = "TARGET ELIMINATED";
                endTitle.style.color = PLAYER_COLOR;
                score += 100;
            } else {
                endTitle.innerText = "CRITICAL FAILURE";
                endTitle.style.color = ENEMY_COLOR;
            }
            endScore.innerText = "System Integrity: " + score + "%";
        }

        let shakeFrames = 0;
        function shakeScreen() {
            shakeFrames = 10;
        }

        // AI Logic
        function updateAI() {
            if (enemy.cooldown > 0) enemy.cooldown--;

            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            // Simple State Machine
            if (dist < SABER_RANGE + SIZE) {
                // Attack range
                if (enemy.cooldown <= 0) {
                    enemy.cooldown = COOLDOWN + 20; // Slower than player
                    // Attack
                    const hitX = enemy.dir === 1 ? enemy.x + SIZE : enemy.x - SABER_WIDTH;
                    if (rectIntersect(hitX, enemy.y, SABER_WIDTH, SIZE, player.x, player.y, SIZE, SIZE)) {
                        player.hp -= 10;
                        player.x += enemy.dir * 10;
                        shakeScreen();
                        if (player.hp <= 0) endGame(false);
                    }
                }
            } else {
                // Chase
                if (dx > 0) { enemy.vx = SPEED * 0.6; enemy.dir = 1; }
                else { enemy.vx = -SPEED * 0.6; enemy.dir = -1; }

                if (dy > 0) enemy.vy = SPEED * 0.6;
                else enemy.vy = -SPEED * 0.6;
            }

            enemy.x += enemy.vx;
            enemy.y += enemy.vy;
            enemy.vx = 0;
            enemy.vy = 0;

            // Bounds
            enemy.x = Math.max(0, Math.min(canvas.width - SIZE, enemy.x));
            enemy.y = Math.max(0, Math.min(canvas.height - SIZE, enemy.y));
        }

        function update() {
            if (!gameRunning) return;

            // Player Physics
            player.x += player.vx;
            player.y += player.vy;

            // Bounds
            player.x = Math.max(0, Math.min(canvas.width - SIZE, player.x));
            player.y = Math.max(0, Math.min(canvas.height - SIZE, player.y));

            if (player.cooldown > 0) player.cooldown--;

            updateAI();
            updateHealthUI();
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Shake effect
            if (shakeFrames > 0) {
                ctx.save();
                const dx = (Math.random() - 0.5) * 10;
                const dy = (Math.random() - 0.5) * 10;
                ctx.translate(dx, dy);
                shakeFrames--;
            }

            // Grid Floor (Noir style)
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for(let i=0; i<canvas.width; i+=40) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
            }
            for(let i=0; i<canvas.height; i+=40) {
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); ctx.stroke();
            }

            // Draw Player
            ctx.fillStyle = PLAYER_COLOR;
            ctx.shadowBlur = 10;
            ctx.shadowColor = PLAYER_COLOR;
            ctx.fillRect(player.x, player.y, SIZE, SIZE);
            
            // Player Saber
            if (player.cooldown > COOLDOWN - 10) {
                ctx.fillStyle = '#fff'; // Flash white on hit
            } else {
                ctx.fillStyle = SABER_COLOR;
            }
            const pSaberX = player.dir === 1 ? player.x + SIZE : player.x - SABER_WIDTH;
            ctx.fillRect(pSaberX, player.y + 5, SABER_WIDTH, SIZE - 10);

            // Draw Enemy
            ctx.fillStyle = ENEMY_COLOR;
            ctx.shadowColor = ENEMY_COLOR;
            ctx.fillRect(enemy.x, enemy.y, SIZE, SIZE);

            // Enemy Saber
            ctx.fillStyle = ENEMY_COLOR; // Enemy saber is red
            const eSaberX = enemy.dir === 1 ? enemy.x + SIZE : enemy.x - SABER_WIDTH;
            ctx.fillRect(eSaberX, enemy.y + 5, SABER_WIDTH, SIZE - 10);

            ctx.shadowBlur = 0;

            if (shakeFrames > 0) ctx.restore();
        }

        function gameLoop() {
            if (gameRunning) {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
        }

        // Initial Draw
        draw();

    </script>
</body>
</html>